{"ts":1362806583122,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1362806607952,"patch":[[{"diffs":[[1,"//Lamog, Rob\n//h1\n//Hart\n//03/07/13\n\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstruct Address{\n    unsigned number;\t//\te.g. 6401 (disallowing fractional addresses)\n\tstring street;\t\t//\te.g. “Winnetka”\n\tstring suffix;\t\t//\te.g. “Avenue”\n\tstring city;\t\t//\te.g. “Woodland Hills”\n\tstring state;\t\t//\te.g. “CA”\n\tunsigned zip;\t\t//\te.g. 91371 (no zip+4)\n};\n\n\t//\tWe’re not going to worry about time zones, daylight saving time, fractions of a second,\n\t//\t\tseconds, leap seconds, months, years, or leap years.\n\t//\tWe’re just indicating a time in a generic week.\n\t//\tThe first time in a week is 12:00 AM Sunday, one minute later is 12:01 AM Sunday\n\t//\tThe last time in a week is 11:59 PM Saturday\n\t//\tThere are 7 * 24 * 60 == 10080 possible times,\n\t//\t\tbecause there are 10080 minutes in a week.\nstruct Time{\n\t\t//\talways in [0, 6]:\n\t\t//\t0 means Sunday, 1 means Monday, ... , 6 means Saturday\n\tunsigned day;\n\t\t//\tfalse means at or after midnight, and before the following noon (AM)\n\t\t//\ttrue means at or after noon, and before the following midnight (PM)\n\tbool pm;\n\tunsigned hour;\t\t//\tin [1, 12], e.g. 12 for 12 o’clock\n\tunsigned minute;\t//\tin [0, 59]\n};\t//\tstruct Time\n\nvoid show( const Address & address );\nvoid show( const Address address[], unsigned elements, unsigned desiredZip );\nvoid show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements );\nstring convertDayToString(const Time &time); //my own function\nvoid show( const Time & time );\nbool ok( const Time & time );\nint compare( const Time & time0, const Time & time1 );\nvoid input( Time & time );\n\nint main() {\n\t//Loading up Address structs for testing\n\tAddress a1 = {21136, \"Alaminos\", \"Drive\", \"Santa Clarita\", \"CA\", 91350};\n\tAddress a2 = {27007, \"Santa Clarita\", \"Lane\", \"Santa Clarita\", \"CA\", 91350};\n\tAddress a3 = {625, \"Lincoln\", \"Boulevard\", \"Venice\", \"CA\", 90291};\n\tAddress a4 = {2819, \"Pico\", \"Boulevard\", \"Santa Monica\", \"CA\", 90404};\n\tAddress a5 = {750, \"First\", \"Street\", \"Lake Oswega\", \"OR\", 97034};\n\tAddress a6 = {18212, \"Chase\", \"Street\", \"Northridge\", \"CA\", 91324};\n\tAddress a7 = {5325, \"Kester\", \"Avenue\", \"Van Nuys\", \"CA\", 91411};\n\t//Loading array of Address structs for second function\n\tAddress addyList[7] = {a1, a2, a3, a4, a5, a6, a7};\n\t//Loading array of desired zips for third function\n\tunsigned zipList[2] = {91350, 91411};\n\t//Loading up Time structs for testing\n\tTime t1 = {5, false, 1, 15};\n\tTime t2 = {0, 0, 12, 00};\n\tTime t3 = {4, true, 5, 30};\n\tTime t4 = {1, false, 11, 0};\n\tTime t5 = {6, 1, 9, 1};\n/*\n\t//Testing Address functions\n\t//First function\n\tshow(a1);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\t//Second function\n\tshow(addyList, 7, 91350);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\t//Third function\n\tshow(addyList, 7, zipList, 2);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n*/\t\n\t//Testing Time functions\n\t//Fourth function\n\tshow(t2);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\tcout << endl;\n\treturn 0;\n} //main\n\nvoid show( const Address & address ) {\n\tcout << address.number << \" \" << address.street << \" \" << address.suffix << endl\n\t<< address.city << \", \" << address.state << \" \" << address.zip << endl;\n\t\n\t//Test this line locally instead of in sourceLair. %s doesn't like dot notation in sourceLair or everywhere?\n\t//printf(\"%u %s %s/n%s %s %u\", address.number, address.street, address.suffix, address.city, address.state, address.zip);\n} //show( const Address & address )\n\nvoid show( const Address address[], unsigned elements, unsigned desiredZip ) {\n\tfor (int i = 0; i < elements; i++){\n\t\tif (desiredZip == address[i].zip){\n\t\t\tshow(address[i]);\n\t\t\tcout << \"------------------------------\" << endl;\n\t\t}\n\t}\n} //show( const Address address[], unsigned elements, unsigned desiredZip )\n\nvoid show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements ) {\n\tfor (int i = 0; i < desiredZipElements; i++){\n\t\tfor (int j = 0; j < addressElements; j++){\n\t\t\tif (desiredZip[i] == address[j].zip){\n\t\t\t\tshow(address[j]);\n\t\t\t\tcout << \"------------------------------\" << endl;\n\t\t\t}\n\t\t}\n\t}\n} //show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements )\n\nstring convertDayToString(const Time &time) {\n\tconst string days[7] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\n\treturn days[time.day];\n} //convertDayToString(const Time &time)\n\nvoid show( const Time & time ){\n\tcout << convertDayToString(time) << \" \" << time.hour << \":\";\n\tif (time.minute == 0) cout << \"00\" << \" \";\n\telse cout << time.minute << \" \";\n\tif (time.pm == 0) cout << \"AM\" << endl;\n\telse cout << \"PM\" << endl;\n} //show( const Time & time )\n"]],"start1":0,"start2":0,"length1":0,"length2":4718}]],"length":4718,"saved":false}
{"ts":1362811001387,"patch":[[{"diffs":[[0,"e t1 = {"],[-1,"5"],[1,"0"],[0,", false,"]],"start1":2471,"start2":2471,"length1":17,"length2":17},{"diffs":[[0,"e, 1"],[1,"2"],[0,", 1"],[-1,"5"],[0,"};\n\t"]],"start1":2486,"start2":2486,"length1":12,"length2":12},{"diffs":[[0," 0, 12, "],[-1,"0"],[0,"0};\n\tTim"]],"start1":2511,"start2":2511,"length1":17,"length2":16},{"diffs":[[0,"se, 11, "],[1,"6"],[0,"0};"],[1," //Should return false time input"],[0,"\n\tTime t"]],"start1":2570,"start2":2570,"length1":19,"length2":53},{"diffs":[[0,"e t5 = {"],[-1,"6"],[1,"7"],[0,", 1, 9, "]],"start1":2620,"start2":2620,"length1":17,"length2":17},{"diffs":[[0,", 9, 1};"],[1," //Should return false time input\n\tTime t6 = {0, 0, 12, 0};\n"],[0,"\n/*\n\t//T"]],"start1":2632,"start2":2632,"length1":16,"length2":76},{"diffs":[[0,"dl;\n"],[-1,"*/"],[0,""],[1,""],[0,"\t\n\t/"]],"start1":2948,"start2":2948,"length1":10,"length2":8},{"diffs":[[0,"endl;\n\t\n"],[1,"\t//Fifth function\n\tcout << ok(t2) << endl;\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n*/\n\t//Sixth function\n\tcout << compare(t1, t2) << endl;\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n"],[0,"\tcout <<"]],"start1":3034,"start2":3034,"length1":16,"length2":176},{"diffs":[[0,"e &time)"],[-1," "],[0,""],[1,""],[0,"{\n\tconst"]],"start1":4515,"start2":4515,"length1":17,"length2":16},{"diffs":[[0,"\n} //show( const"],[-1,""],[0,""],[1," Time & time )\n\nbool ok( const Time & time ){\n\tif ((time.day < 0) || (time.day >= 7)) return false;\n\tif ((time.hour < 1) || (time.hour >= 13)) return false;\n\tif ((time.minute < 0) || (time.minute >= 60)) return false;\n\treturn true;\n} //bool ok( const Time & time )\n\nint compare( const Time & time0, const Time & time1 ){\n\tstring msg = \"Time/s incorrectly entered.\";\n\t\n\tif ((!ok(time0)) || (!ok(time1))){\n\t\t//cerr <<endl <<\"Fatal error: \" <<msg <<endl;\n\t\t//exit( EXIT_FAILURE );\n\t\t\n\t\tcout << endl << \"Fatal error: \" << msg << endl;\n\t}\n\t\n\tif (time0.day < time1.day) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == false) && (time1.pm == true)) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == time1.pm) && (time0.hour < time1.hour)) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == time1.pm) && (time0.hour == time1.hour) && (time0.minute < time1.minute)) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == time1.pm) && (time0.hour == time1.hour) && (time0.minute == time1.minute)) return 0;\n\telse return 1;\n\treturn 9999; //bogus return in case of error\n} //int compare( const Time & time0, const Time & time1 )\n\nvoid input( Time & time ){\n\t\n} //void input("],[0," Time & time )\n"]],"start1":4937,"start2":4937,"length1":31,"length2":1237}]],"length":6174,"saved":false}
