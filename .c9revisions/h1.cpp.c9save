{"ts":1362806583122,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1362806607952,"patch":[[{"diffs":[[1,"//Lamog, Rob\n//h1\n//Hart\n//03/07/13\n\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstruct Address{\n    unsigned number;\t//\te.g. 6401 (disallowing fractional addresses)\n\tstring street;\t\t//\te.g. “Winnetka”\n\tstring suffix;\t\t//\te.g. “Avenue”\n\tstring city;\t\t//\te.g. “Woodland Hills”\n\tstring state;\t\t//\te.g. “CA”\n\tunsigned zip;\t\t//\te.g. 91371 (no zip+4)\n};\n\n\t//\tWe’re not going to worry about time zones, daylight saving time, fractions of a second,\n\t//\t\tseconds, leap seconds, months, years, or leap years.\n\t//\tWe’re just indicating a time in a generic week.\n\t//\tThe first time in a week is 12:00 AM Sunday, one minute later is 12:01 AM Sunday\n\t//\tThe last time in a week is 11:59 PM Saturday\n\t//\tThere are 7 * 24 * 60 == 10080 possible times,\n\t//\t\tbecause there are 10080 minutes in a week.\nstruct Time{\n\t\t//\talways in [0, 6]:\n\t\t//\t0 means Sunday, 1 means Monday, ... , 6 means Saturday\n\tunsigned day;\n\t\t//\tfalse means at or after midnight, and before the following noon (AM)\n\t\t//\ttrue means at or after noon, and before the following midnight (PM)\n\tbool pm;\n\tunsigned hour;\t\t//\tin [1, 12], e.g. 12 for 12 o’clock\n\tunsigned minute;\t//\tin [0, 59]\n};\t//\tstruct Time\n\nvoid show( const Address & address );\nvoid show( const Address address[], unsigned elements, unsigned desiredZip );\nvoid show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements );\nstring convertDayToString(const Time &time); //my own function\nvoid show( const Time & time );\nbool ok( const Time & time );\nint compare( const Time & time0, const Time & time1 );\nvoid input( Time & time );\n\nint main() {\n\t//Loading up Address structs for testing\n\tAddress a1 = {21136, \"Alaminos\", \"Drive\", \"Santa Clarita\", \"CA\", 91350};\n\tAddress a2 = {27007, \"Santa Clarita\", \"Lane\", \"Santa Clarita\", \"CA\", 91350};\n\tAddress a3 = {625, \"Lincoln\", \"Boulevard\", \"Venice\", \"CA\", 90291};\n\tAddress a4 = {2819, \"Pico\", \"Boulevard\", \"Santa Monica\", \"CA\", 90404};\n\tAddress a5 = {750, \"First\", \"Street\", \"Lake Oswega\", \"OR\", 97034};\n\tAddress a6 = {18212, \"Chase\", \"Street\", \"Northridge\", \"CA\", 91324};\n\tAddress a7 = {5325, \"Kester\", \"Avenue\", \"Van Nuys\", \"CA\", 91411};\n\t//Loading array of Address structs for second function\n\tAddress addyList[7] = {a1, a2, a3, a4, a5, a6, a7};\n\t//Loading array of desired zips for third function\n\tunsigned zipList[2] = {91350, 91411};\n\t//Loading up Time structs for testing\n\tTime t1 = {5, false, 1, 15};\n\tTime t2 = {0, 0, 12, 00};\n\tTime t3 = {4, true, 5, 30};\n\tTime t4 = {1, false, 11, 0};\n\tTime t5 = {6, 1, 9, 1};\n/*\n\t//Testing Address functions\n\t//First function\n\tshow(a1);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\t//Second function\n\tshow(addyList, 7, 91350);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\t//Third function\n\tshow(addyList, 7, zipList, 2);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n*/\t\n\t//Testing Time functions\n\t//Fourth function\n\tshow(t2);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\tcout << endl;\n\treturn 0;\n} //main\n\nvoid show( const Address & address ) {\n\tcout << address.number << \" \" << address.street << \" \" << address.suffix << endl\n\t<< address.city << \", \" << address.state << \" \" << address.zip << endl;\n\t\n\t//Test this line locally instead of in sourceLair. %s doesn't like dot notation in sourceLair or everywhere?\n\t//printf(\"%u %s %s/n%s %s %u\", address.number, address.street, address.suffix, address.city, address.state, address.zip);\n} //show( const Address & address )\n\nvoid show( const Address address[], unsigned elements, unsigned desiredZip ) {\n\tfor (int i = 0; i < elements; i++){\n\t\tif (desiredZip == address[i].zip){\n\t\t\tshow(address[i]);\n\t\t\tcout << \"------------------------------\" << endl;\n\t\t}\n\t}\n} //show( const Address address[], unsigned elements, unsigned desiredZip )\n\nvoid show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements ) {\n\tfor (int i = 0; i < desiredZipElements; i++){\n\t\tfor (int j = 0; j < addressElements; j++){\n\t\t\tif (desiredZip[i] == address[j].zip){\n\t\t\t\tshow(address[j]);\n\t\t\t\tcout << \"------------------------------\" << endl;\n\t\t\t}\n\t\t}\n\t}\n} //show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements )\n\nstring convertDayToString(const Time &time) {\n\tconst string days[7] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\n\treturn days[time.day];\n} //convertDayToString(const Time &time)\n\nvoid show( const Time & time ){\n\tcout << convertDayToString(time) << \" \" << time.hour << \":\";\n\tif (time.minute == 0) cout << \"00\" << \" \";\n\telse cout << time.minute << \" \";\n\tif (time.pm == 0) cout << \"AM\" << endl;\n\telse cout << \"PM\" << endl;\n} //show( const Time & time )\n"]],"start1":0,"start2":0,"length1":0,"length2":4718}]],"length":4718,"saved":false}
