{"ts":1362806583122,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1362806607952,"patch":[[{"diffs":[[1,"//Lamog, Rob\n//h1\n//Hart\n//03/07/13\n\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\n\nstruct Address{\n    unsigned number;\t//\te.g. 6401 (disallowing fractional addresses)\n\tstring street;\t\t//\te.g. “Winnetka”\n\tstring suffix;\t\t//\te.g. “Avenue”\n\tstring city;\t\t//\te.g. “Woodland Hills”\n\tstring state;\t\t//\te.g. “CA”\n\tunsigned zip;\t\t//\te.g. 91371 (no zip+4)\n};\n\n\t//\tWe’re not going to worry about time zones, daylight saving time, fractions of a second,\n\t//\t\tseconds, leap seconds, months, years, or leap years.\n\t//\tWe’re just indicating a time in a generic week.\n\t//\tThe first time in a week is 12:00 AM Sunday, one minute later is 12:01 AM Sunday\n\t//\tThe last time in a week is 11:59 PM Saturday\n\t//\tThere are 7 * 24 * 60 == 10080 possible times,\n\t//\t\tbecause there are 10080 minutes in a week.\nstruct Time{\n\t\t//\talways in [0, 6]:\n\t\t//\t0 means Sunday, 1 means Monday, ... , 6 means Saturday\n\tunsigned day;\n\t\t//\tfalse means at or after midnight, and before the following noon (AM)\n\t\t//\ttrue means at or after noon, and before the following midnight (PM)\n\tbool pm;\n\tunsigned hour;\t\t//\tin [1, 12], e.g. 12 for 12 o’clock\n\tunsigned minute;\t//\tin [0, 59]\n};\t//\tstruct Time\n\nvoid show( const Address & address );\nvoid show( const Address address[], unsigned elements, unsigned desiredZip );\nvoid show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements );\nstring convertDayToString(const Time &time); //my own function\nvoid show( const Time & time );\nbool ok( const Time & time );\nint compare( const Time & time0, const Time & time1 );\nvoid input( Time & time );\n\nint main() {\n\t//Loading up Address structs for testing\n\tAddress a1 = {21136, \"Alaminos\", \"Drive\", \"Santa Clarita\", \"CA\", 91350};\n\tAddress a2 = {27007, \"Santa Clarita\", \"Lane\", \"Santa Clarita\", \"CA\", 91350};\n\tAddress a3 = {625, \"Lincoln\", \"Boulevard\", \"Venice\", \"CA\", 90291};\n\tAddress a4 = {2819, \"Pico\", \"Boulevard\", \"Santa Monica\", \"CA\", 90404};\n\tAddress a5 = {750, \"First\", \"Street\", \"Lake Oswega\", \"OR\", 97034};\n\tAddress a6 = {18212, \"Chase\", \"Street\", \"Northridge\", \"CA\", 91324};\n\tAddress a7 = {5325, \"Kester\", \"Avenue\", \"Van Nuys\", \"CA\", 91411};\n\t//Loading array of Address structs for second function\n\tAddress addyList[7] = {a1, a2, a3, a4, a5, a6, a7};\n\t//Loading array of desired zips for third function\n\tunsigned zipList[2] = {91350, 91411};\n\t//Loading up Time structs for testing\n\tTime t1 = {5, false, 1, 15};\n\tTime t2 = {0, 0, 12, 00};\n\tTime t3 = {4, true, 5, 30};\n\tTime t4 = {1, false, 11, 0};\n\tTime t5 = {6, 1, 9, 1};\n/*\n\t//Testing Address functions\n\t//First function\n\tshow(a1);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\t//Second function\n\tshow(addyList, 7, 91350);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\t//Third function\n\tshow(addyList, 7, zipList, 2);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n*/\t\n\t//Testing Time functions\n\t//Fourth function\n\tshow(t2);\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n\tcout << endl;\n\treturn 0;\n} //main\n\nvoid show( const Address & address ) {\n\tcout << address.number << \" \" << address.street << \" \" << address.suffix << endl\n\t<< address.city << \", \" << address.state << \" \" << address.zip << endl;\n\t\n\t//Test this line locally instead of in sourceLair. %s doesn't like dot notation in sourceLair or everywhere?\n\t//printf(\"%u %s %s/n%s %s %u\", address.number, address.street, address.suffix, address.city, address.state, address.zip);\n} //show( const Address & address )\n\nvoid show( const Address address[], unsigned elements, unsigned desiredZip ) {\n\tfor (int i = 0; i < elements; i++){\n\t\tif (desiredZip == address[i].zip){\n\t\t\tshow(address[i]);\n\t\t\tcout << \"------------------------------\" << endl;\n\t\t}\n\t}\n} //show( const Address address[], unsigned elements, unsigned desiredZip )\n\nvoid show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements ) {\n\tfor (int i = 0; i < desiredZipElements; i++){\n\t\tfor (int j = 0; j < addressElements; j++){\n\t\t\tif (desiredZip[i] == address[j].zip){\n\t\t\t\tshow(address[j]);\n\t\t\t\tcout << \"------------------------------\" << endl;\n\t\t\t}\n\t\t}\n\t}\n} //show( const Address address[], unsigned addressElements, const unsigned desiredZip[], unsigned desiredZipElements )\n\nstring convertDayToString(const Time &time) {\n\tconst string days[7] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\n\treturn days[time.day];\n} //convertDayToString(const Time &time)\n\nvoid show( const Time & time ){\n\tcout << convertDayToString(time) << \" \" << time.hour << \":\";\n\tif (time.minute == 0) cout << \"00\" << \" \";\n\telse cout << time.minute << \" \";\n\tif (time.pm == 0) cout << \"AM\" << endl;\n\telse cout << \"PM\" << endl;\n} //show( const Time & time )\n"]],"start1":0,"start2":0,"length1":0,"length2":4718}]],"length":4718,"saved":false}
{"ts":1362811001387,"patch":[[{"diffs":[[0,"e t1 = {"],[-1,"5"],[1,"0"],[0,", false,"]],"start1":2471,"start2":2471,"length1":17,"length2":17},{"diffs":[[0,"e, 1"],[1,"2"],[0,", 1"],[-1,"5"],[0,"};\n\t"]],"start1":2486,"start2":2486,"length1":12,"length2":12},{"diffs":[[0," 0, 12, "],[-1,"0"],[0,"0};\n\tTim"]],"start1":2511,"start2":2511,"length1":17,"length2":16},{"diffs":[[0,"se, 11, "],[1,"6"],[0,"0};"],[1," //Should return false time input"],[0,"\n\tTime t"]],"start1":2570,"start2":2570,"length1":19,"length2":53},{"diffs":[[0,"e t5 = {"],[-1,"6"],[1,"7"],[0,", 1, 9, "]],"start1":2620,"start2":2620,"length1":17,"length2":17},{"diffs":[[0,", 9, 1};"],[1," //Should return false time input\n\tTime t6 = {0, 0, 12, 0};\n"],[0,"\n/*\n\t//T"]],"start1":2632,"start2":2632,"length1":16,"length2":76},{"diffs":[[0,"dl;\n"],[-1,"*/"],[0,""],[1,""],[0,"\t\n\t/"]],"start1":2948,"start2":2948,"length1":10,"length2":8},{"diffs":[[0,"endl;\n\t\n"],[1,"\t//Fifth function\n\tcout << ok(t2) << endl;\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n*/\n\t//Sixth function\n\tcout << compare(t1, t2) << endl;\n\tcout << \"\\\\/\\\\_[=]\" << endl;\n\t\n"],[0,"\tcout <<"]],"start1":3034,"start2":3034,"length1":16,"length2":176},{"diffs":[[0,"e &time)"],[-1," "],[0,""],[1,""],[0,"{\n\tconst"]],"start1":4515,"start2":4515,"length1":17,"length2":16},{"diffs":[[0,"\n} //show( const"],[-1,""],[0,""],[1," Time & time )\n\nbool ok( const Time & time ){\n\tif ((time.day < 0) || (time.day >= 7)) return false;\n\tif ((time.hour < 1) || (time.hour >= 13)) return false;\n\tif ((time.minute < 0) || (time.minute >= 60)) return false;\n\treturn true;\n} //bool ok( const Time & time )\n\nint compare( const Time & time0, const Time & time1 ){\n\tstring msg = \"Time/s incorrectly entered.\";\n\t\n\tif ((!ok(time0)) || (!ok(time1))){\n\t\t//cerr <<endl <<\"Fatal error: \" <<msg <<endl;\n\t\t//exit( EXIT_FAILURE );\n\t\t\n\t\tcout << endl << \"Fatal error: \" << msg << endl;\n\t}\n\t\n\tif (time0.day < time1.day) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == false) && (time1.pm == true)) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == time1.pm) && (time0.hour < time1.hour)) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == time1.pm) && (time0.hour == time1.hour) && (time0.minute < time1.minute)) return -1;\n\telse if ((time0.day == time1.day) && (time0.pm == time1.pm) && (time0.hour == time1.hour) && (time0.minute == time1.minute)) return 0;\n\telse return 1;\n\treturn 9999; //bogus return in case of error\n} //int compare( const Time & time0, const Time & time1 )\n\nvoid input( Time & time ){\n\t\n} //void input("],[0," Time & time )\n"]],"start1":4937,"start2":4937,"length1":31,"length2":1237}]],"length":6174,"saved":false}
{"contributors":[],"silentsave":false,"ts":1363837063175,"patch":[[{"diffs":[[0,"e <c"],[-1,"stdio>\n#include <iomanip"],[1,"ctype"],[0,">\n#i"]],"start1":44,"start2":44,"length1":32,"length2":13},{"diffs":[[0,"t Time\n\n"],[1,"bool die( const string & msg );\n"],[0,"void sho"]],"start1":1204,"start2":1204,"length1":16,"length2":48},{"diffs":[[0," & time1 );\n"],[1,"int convertStringToDay(const string &day); //my own function\n"],[0,"void input( "]],"start1":1650,"start2":1650,"length1":24,"length2":85},{"diffs":[[0," 12, 0};"],[1,"\n\tTime t7;"],[0,"\n\n/*\n\t//"]],"start1":2765,"start2":2765,"length1":16,"length2":26},{"diffs":[[0,";\n\tcout << \""],[-1,"\\\\/\\\\_[=]"],[1,"]===["],[0,"\" << endl;\n\t"]],"start1":2844,"start2":2844,"length1":33,"length2":29},{"diffs":[[0,";\n\tcout << \""],[-1,"\\\\/\\\\_[=]"],[1,"]===["],[0,"\" << endl;\n\t"]],"start1":2918,"start2":2918,"length1":33,"length2":29},{"diffs":[[0,";\n\tcout << \""],[-1,"\\\\/\\\\_[=]"],[1,"]===["],[0,"\" << endl;\n\t"]],"start1":2996,"start2":2996,"length1":33,"length2":29},{"diffs":[[0,";\n\tcout << \""],[-1,"\\\\/\\\\_[=]"],[1,"]===["],[0,"\" << endl;\n\t"]],"start1":3080,"start2":3080,"length1":33,"length2":29},{"diffs":[[0,";\n\tcout << \""],[-1,"\\\\/\\\\_[=]"],[1,"]===["],[0,"\" << endl;\n*"]],"start1":3151,"start2":3151,"length1":33,"length2":29},{"diffs":[[0,"dl;\n"],[-1,"*/"],[0,"\n\t//"]],"start1":3175,"start2":3175,"length1":10,"length2":8},{"diffs":[[0,"<< \""],[-1,"\\\\/\\\\_[=]"],[1,"]===[\" << endl;\n*/\t\n\t//Seventh function\n\tinput(t7);\n\tshow(t7);\n\tcout << \"]===["],[0,"\" <<"]],"start1":3238,"start2":3238,"length1":17,"length2":86},{"diffs":[[0,"< endl;\n"],[-1,"\t"],[0,"\n\tcout <"]],"start1":3323,"start2":3323,"length1":17,"length2":16},{"diffs":[[0,"//main\n\n"],[1,"bool die( const string & msg ){\n\t\t//cerr <<endl <<\"Fatal error: \" <<msg <<endl;\n\t\t//exit( EXIT_FAILURE );\n\t\t\n\t\tcout << endl << \"Fatal error: \" << msg << endl;\n}\n\n"],[0,"void sho"]],"start1":3360,"start2":3360,"length1":16,"length2":178},{"diffs":[[0,"<< \" \";\n"],[1,"\telse if (time.minute < 10) cout << \"0\" << time.minute << \" \";\n"],[0,"\telse co"]],"start1":5119,"start2":5119,"length1":16,"length2":79},{"diffs":[[0,"ay >"],[-1,"= 7"],[1," 6"],[0,")) r"]],"start1":5384,"start2":5384,"length1":11,"length2":10},{"diffs":[[0,"ur >"],[-1,"="],[0," 1"],[-1,"3"],[1,"2"],[0,")) r"]],"start1":5439,"start2":5439,"length1":12,"length2":11},{"diffs":[[0,"te >"],[-1,"= 60"],[1," 59"],[0,")) r"]],"start1":5499,"start2":5499,"length1":12,"length2":11},{"diffs":[[0,"){\n\t"],[-1,"string msg = \"Time/s incorrectly entered.\";\n\t\n\tif ((!ok(time0)) || (!ok(time1))){\n\t\t//cerr <<endl <<\"Fatal error: \" <<msg <<endl;\n\t\t//exit( EXIT_FAILURE );\n\t\t\n\t\tcout << endl << \"Fatal error: \" << msg << endl;\n\t}"],[1,"if ((!ok(time0)) || (!ok(time1))) die(\"Time/s incorrectly entered.\");"],[0,"\n\t\n\t"]],"start1":5623,"start2":5623,"length1":219,"length2":77},{"diffs":[[0," )\n\n"],[-1,"void input( Time & time ){\n"],[1,"int convertStringToDay(const string &day){\n\tif (day == \"Sunday\") return 0;\n\tif (day == \"Monday\") return 1;\n\tif (day == \"Tuesday\") return 2;\n\tif (day == \"Wednesday\") return 3;\n\tif (day == \"Thursday\") return 4;\n\tif (day == \"Friday\") return 5;\n\tif (day == \"Saturday\") return 6;\n\treturn 9999; //bogus return in case of error\n} //convertStringToDay(const string &day)\n\nvoid input( Time & time ){\n\tstring inputStr;\n\tstring day, amPM;\n\tunsigned found, hour, minute;\n\t\n\t//Wednesday  7:05 PM\n\tcin >> inputStr;\n\tif (convertStringToDay(inputStr) != 9999) time.day = convertStringToDay(inputStr);\n\telse die(\"Invalid day entry.\");\n\t//cout << convertStringToDay(inputStr) << endl;\n\t\n\tcin >> inputStr;\n\tfound = inputStr.find(\":\");\n\t//cout << found << endl;\n\tif (found == 2){\n\t\tif (isdigit(inputStr[0]) && isdigit(inputStr[1])){\n\t\t\t\tstringstream(inputStr.substr(0, 2)) >> hour;\n\t\t\t\tif ((hour > 0) && (hour < 13)) time.hour =  hour;\n\t\t\t\telse die(\"Hour entry outside of hour range.\");\n\t\t} else die(\"Invalid hour entry.\");\n\t\tif (isdigit(inputStr[3]) && isdigit(inputStr[4])){\n\t\t\t\tstringstream(inputStr.substr(3, 2)) >> minute;\n\t\t\t\tif ((minute >= 0) && (minute <= 59)) time.minute = minute;\n\t\t\t\telse die(\"Minute entry outside of minute range.\");\n\t\t} else die(\"Invalid minute entry.\");\n\t}\n\telse if (found == 1){\n\t\tif (isdigit(inputStr[0])){\n\t\t\tstringstream(inputStr.substr(0, 1)) >> hour;\n\t\t\ttime.hour =  hour;\n\t\t} else die(\"Invalid hour entry.\");\n\t\tif (isdigit(inputStr[2]) && isdigit(inputStr[3])){\n\t\t\t\tstringstream(inputStr.substr(2, 2)) >> minute;\n\t\t\t\tif ((minute >= 0) && (minute <= 59)) time.minute = minute;\n\t\t\t\telse die(\"Minute entry outside of minute range.\");\n\t\t} else die(\"Invalid minute entry.\");\n\t} else die(\"Invalid time entry.\");\n\t//cout << hour << endl;\n\t//cout << minute << endl;\n\t\n\tcin >> inputStr;\n\tif (inputStr == \"AM\") time.pm = false;\n\telse if (inputStr == \"PM\") time.pm = true;\n\telse die(\"Invalid AM/PM entry.\");\n\n\t//cout << time.day << \" \" << time.hour << \":\" << time.minute << \" \" << time.pm << endl;\n\t\t\t\t\t\t\t\t\t\t\t\n/*\tgetline (cin, inputStr); //this method poses a lot of challenges. may have come out to fewer lines but the simple method above did the trick just fine by me.\n\t\n\tfound = inputStr.find(\" \");\n\tday = inputStr.substr(0, found);\n\t//cout << day << endl;\n\tfound = inputStr.find_first_of(\"123456789\");\n\ttimeInput = inputStr.substr(found, inputStr.length());\n\tfound = timeInput.find(\":\");\n\t//cout << found << endl;\n\tif (found == 2){\n\t\tstringstream(timeInput.substr(0, 2)) >> hour;\n\t\tstringstream(timeInput.substr(2, 2)) >> minute;\n\t} else {\n\t\tstringstream(timeInput.substr(0, 1)) >> hour;\n\t\tstringstream(timeInput.substr(2, 2)) >> minute;\n\t}\n\tcout << hour << endl;\n\tcout << minute << endl;\n\tfound = timeInput.find(\" \");\n\tif (timeInput.find(\"AM\")) amPM = \"AM\";\n\t\n\t//cout << amPM << endl;\n*/"],[0,"\t\n} "]],"start1":6321,"start2":6321,"length1":35,"length2":2807}]],"length":9156,"saved":false}
